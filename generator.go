package filterx

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
)

type Generator struct {
	o *Options
}

// FieldInfo 描述生成结构体的字段信息
type FieldInfo struct {
	Name       string
	Type       string
	JsonTag    string
	FilterxTag string
}

// TemplateData 模板数据
type TemplateData struct {
	PackageName   string
	StructName    string
	Fields        []FieldInfo
	FilterxImport []string
}

const filterxTemplate = `// Code generated by filterx generator; DO NOT EDIT.
package {{.PackageName}}

import (
	{{- range .FilterxImport}}
		"{{.}}"
	{{- end}}
)

type {{.StructName}}Filterx struct {
{{- range .Fields}}
	{{.Name}} filterx.Predicate[{{.Type}}] ` + "`json:\"{{.JsonTag}}\" filterx:\"{{.FilterxTag}}\"`" + `
{{- end}}
}
`

const filterxGormTemplate = `// Code generated by filterx generator; DO NOT EDIT.
package {{.PackageName}}

import (
	"gorm.io/gorm"
)

func (cuf {{.StructName}}Filterx) GormHelper(db *gorm.DB) *gorm.DB {
	{{- range .Fields}}
		if cuf.{{.Name}} != nil {
			if f, ok := cuf.{{.Name}}.Filter().GetGT(); ok {
				db = db.Where("{{.FilterxTag}} > ?", f.Value)
			}
		}

		if cuf.{{.Name}} != nil {
			if f, ok := cuf.{{.Name}}.Filter().GetEQ(); ok {
				db = db.Where("{{.FilterxTag}} >= ?", f.Value)
			}
		}

		if cuf.{{.Name}} != nil {
			if f, ok := cuf.{{.Name}}.Filter().GetLT(); ok {
				db = db.Where("{{.FilterxTag}} < ?", f.Value)
			}
		}

		if cuf.{{.Name}} != nil {
			if f, ok := cuf.{{.Name}}.Filter().GetGE(); ok {
				db = db.Where("{{.FilterxTag}} >= ?", f.Value)
			}
		}

		if cuf.{{.Name}} != nil {
			if f, ok := cuf.{{.Name}}.Filter().GetLE(); ok {
				db = db.Where("{{.FilterxTag}} <= ?", f.Value)
			}
		}

		if cuf.{{.Name}} != nil {
			if f, ok := cuf.{{.Name}}.Filter().GetRange(); ok {
				db = db.Where("{{.FilterxTag}} >= ? AND {{.FilterxTag}} <= ?", f.Min, f.Max)
			}
		}

		if cuf.{{.Name}} != nil {
			if f, ok := cuf.{{.Name}}.Filter().GetIn(); ok {
				db = db.Where("{{.FilterxTag}} IN ?", f.Values)
			}
		}

		if cuf.{{.Name}} != nil {
			if f, ok := cuf.{{.Name}}.Filter().GetNIn(); ok {
				db = db.Where("{{.FilterxTag}} NOT IN ?", f.Values)
			}
		}
	
		if cuf.{{.Name}} != nil {
			if f, ok := cuf.{{.Name}}.Filter().GetLike(); ok {
				db = db.Where("{{.FilterxTag}} like ?", f.Pattern)
			}
		}
	{{- end}}
	return db
}
`

// Options 结构体，存储配置
type Options struct {
	Output     string
	GormHelper bool
	Packages   []string
}

// Option 函数类型，定义配置函数的签名
type Option func(*Options)

// WithOutput 配置 Output 字段
func WithOutput(path string) Option {
	return func(opts *Options) {
		opts.Output = path
	}
}

// WithGormHelper 配置 GormHelper 字段
func WithGormHelper() Option {
	return func(opts *Options) {
		opts.GormHelper = true
	}
}

// WithPackages 配置 packages 字段
func WithPackages(p []string) Option {
	return func(opts *Options) {
		opts.Packages = p
	}
}

// NewGeneratorOptions 创建 Options 实例，应用所有 Option 函数
func NewGeneratorOptions(opts ...Option) *Generator {
	options := &Options{}

	// 应用所有选项
	for _, opt := range opts {
		opt(options)
	}

	return &Generator{o: options}
}

func getGenPackageName(p string) (string, error) {
	currentDir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	absPath, err := filepath.Abs(filepath.Join(currentDir, p))
	return filepath.Base(absPath), nil
}

func (gen *Generator) Generate(in ...interface{}) error {
	if len(in) == 0 {
		return fmt.Errorf("no input structs provided")
	}

	// 获取当前目录
	packageName, err := getGenPackageName(gen.o.Output)
	if err != nil {
		return fmt.Errorf("failed to get current directory: %v", err)
	}

	// 增加自身包依赖
	gen.o.Packages = append(gen.o.Packages, "github.com/tlsproxy/filterx")

	for _, v := range in {
		err := gen.generate(v, packageName)
		if err != nil {
			return err
		}
	}
	return nil
}

// scanStruct 递归扫描结构体字段，包括匿名嵌套结构
func (gen *Generator) scanStruct(t reflect.Type) []FieldInfo {
	var fields []FieldInfo

	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)

		// 忽略 unexported 字段
		if f.PkgPath != "" {
			continue
		}

		// 匿名嵌套结构，且是 struct 类型，递归展开
		if f.Anonymous && f.Type.Kind() == reflect.Struct {
			nestedFields := gen.scanStruct(f.Type)
			fields = append(fields, nestedFields...)
		} else {
			fields = append(fields, FieldInfo{
				Name:       f.Name,
				Type:       f.Type.String(),
				JsonTag:    f.Tag.Get("json"),
				FilterxTag: f.Tag.Get("filterx"),
			})
		}
	}

	return fields
}

func (gen *Generator) generate(in interface{}, packageName string) error {
	inputType := reflect.TypeOf(in)
	if inputType.Kind() != reflect.Struct {
		return fmt.Errorf("input must be a struct, got %v", inputType.Kind())
	}

	// 获取结构体名称和包信息
	structName := inputType.Name()
	if structName == "" {
		return fmt.Errorf("anonymous structs are not supported")
	}

	structFields := gen.scanStruct(inputType)

	if len(structFields) == 0 {
		return fmt.Errorf("struct %s not found or has no fields", structName)
	}

	// 准备模板数据
	data := TemplateData{
		PackageName:   packageName,
		StructName:    structName,
		Fields:        structFields,
		FilterxImport: gen.o.Packages,
	}

	// 生成结构体
	err := gen.genFile(structName, data, filterxTemplate, "struct")
	if err != nil {
		return err
	}

	if gen.o.GormHelper {
		err = gen.genFile(structName, data, filterxGormTemplate, "gorm")
		if err != nil {
			return err
		}
	}

	return nil

}

func (gen *Generator) genFile(structName string, data TemplateData, temp string, suffix string) error {

	// 解析并执行模板
	tmpl, err := template.New("filterx").Parse(temp)
	if err != nil {
		return fmt.Errorf("failed to parse template: %v", err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, data)
	if err != nil {
		return fmt.Errorf("failed to execute template: %v", err)
	}

	// 确保输出目录存在
	outputDir := filepath.Dir(gen.o.Output)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %v", err)
	}

	// 写入输出文件
	err = os.WriteFile(fmt.Sprintf("%s/%s_%s_gen.go", gen.o.Output, strings.ToLower(structName), suffix), buf.Bytes(), 0644)
	if err != nil {
		return fmt.Errorf("failed to write output file: %v", err)
	}
	return nil
}
